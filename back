#!/bin/bash
# ------------------------------------------------------------------------------
# 
# File: back
# Author: Gabriel Gonzalez
# 
# Brief: A file/directory/system backup program.
# 
# ------------------------------------------------------------------------------

##
# Source utilities.
##
. "commandline.sh"
. "io.sh"

##
# Exit statuses.
##
EXIT_BACKUP_INVALID_DIRECTORY=10
EXIT_BACKUP_INVALID_FILE=11
EXIT_BACKUP_USER_NOT_ROOT=12

##
# Backup.
##
main()
{
    cli_options "-h|--help             |Print program usage." \
                "-b|--backup=src:::    |Backup one or more directories. Must be run with '-d' and, optionally, with '-e'." \
                "-d|--destination=dest:|Destination path to save backup to." \
                "-e|--exclude=dir:::   |Directories to exclude from the backup." \
                "-f|--files=files:::   |Backup one or more files. Appends '.bak' to the name." \
                "-S|--system           |Full sytem backup. Must be run with '-d' and, optionally, with '-e'." \
                "-v|--verbose          |Print verbose output."
    cli_parse "${@}"

    local help=$(cli_get "help")
    local backup=$(cli_get "backup")
    local destination=$(cli_get "destination")
    local exclude=$(cli_get "exclude")
    local files=$(cli_get "files")
    local system=$(cli_get "system")

    if [ -n "${help}" ]
    then
        cli_usage
    elif [ -n "${backup}" ]
    then
        backup_directory "${backup}" "${destination}" "${exclude}"
    elif [ -n "${files}" ]
    then
        backup_file "${files}"
    elif [ -n "${system}" ]
    then
        backup_system "${destination}" "${exclude}"
    else
        :
    fi
    exit $?
}

##
# Backup one or more directories.
##
backup_directory()
{
    local src="${1}"
    local dst="${2}"
    local exclude="${3}"
    if ! backup_directory_verify "${src}" "${dst}"
    then
        return ${EXIT_BACKUP_INVALID_DIRECTORY}
    fi
    rsync_backup "${src}" "${dst}" "${exclude}"
    return $?
}

##
# Backup one or more files.
# 
# Append ".bak" to file backups.
##
backup_file()
{
    local file="${1}"
    local IFS=$'|'
    for f in ${file}
    do
        if ! backup_file_verify "${f}"
        then
           return ${EXIT_BACKUP_INVALID_FILE}
        fi
        cp -anv "${f}" "${f}.bak"
    done
}

##
# Create a full system backup.
##
backup_system()
{
    local src=$(backup_system_get_source)
    local dst="${1}"
    local exclude="${2}"
    backup_system_verify "${src}" "${dst}"
    case $? in
        1) return ${EXIT_BACKUP_INVALID_DIRECTORY} ;;
        2) return ${EXIT_BACKUP_USER_NOT_ROOT} ;;
        *) ;;
    esac

    print_info "Running Full System Backup."

    exclude+="|/home/*/.thumbnails|/home/*/.cache|/home/*/.mozilla/firefox/*.default/storage"
    local src=

    options+="|--link-dest=${dst}"

    local date=$(date +%F)
    local latestlink="${dst}/latest"
    local latestdir="${dst}${date}"
    local log="${latestdir}/Backup_Summary_$(date +%T%z).log"
    mkdir -pv "${latestdir}"

    backup_directory "${src}" "${dst}" "${exclude}" "${options}" \
        | tee -a "${log}"
    sed -i 's/\r/\n/g' "${log}" 

    rm -f "${latestlink}"
    ln -sv "${latestdir}" "${latestlink}"
}

##
# Use rsync to backup.
##
rsync_backup()
{
    local src="${1}"
    local dst="${2}"
    local exclude="${3}"
    local options="${4}"
    local srcdirs=

    # Check existence of source and destination locations
    srcdirs=($(get_source_directories "${src}"))
    if [ $? -ne 0 ]; then
        exit ${STATUS_SRCDIR}
    fi

    local IFS=$'|'
    rsync -aEHAXxPhv ${src} "${dst}"
}

##
# Verify that source and destination exist.
##
backup_directory_verify()
{
    local src="${1}"
    local dst="${2}"
    local IFS=$'|'
    if  ! backup_is_destination "${dst}"
    then
        backup_print_error "directory" "${dst}"
        return 1
    fi
    for d in ${src}
    do
        if ! backup_is_source "${src}"
        then
            backup_print_error "directory" "${d}"
            return 1
        fi
    done
    return 0
}

##
# Verify that file exists.
##
backup_file_verify()
{
    local file="${1}"
    if ! backup_is_file "${file}"
    then
        backup_print_error "file" "${file}"
        return 1
    fi
    return 0
}

##
# Verify that everything is prepared for full system backup.
##
backup_system_verify()
{
    local src="${1}"
    local dst="${2}"
    if [ ${UID} -ne 0 ]
    then
        print_err "Unable to run full system backup: Must be run as root."
        return 2
    fi
    backup_directory_verify "${src}" "${dst}"
    return $?
}

fun()
{
    return 2
}

##
# Return the source directories for a full system backup.
##
backup_system_get_source()
{
    local line=
    local i=0
    local IFS=$'\n'
    local mounts=
    for line in $(df -h -x tmpfs -x devtmpfs)
    do
        i=$[ ${i} + 1 ]
        if [ ${i} -eq 1 ]
        then
            continue
        fi
        local IFS=$' \t'
        local columns=(${line})
        local pt="${columns[5]}"
        case "${pt}" in
            *mnt*|*media*|*srv*) continue ;;
            *) mounts+="${pt}|" ;;
        esac
    done
    echo "${mounts}"
    return 0
}

# ******************************************************************************
# Print backup done message
print_backup_done()
{
    local startsec="${1}"
    local stopsec="${2}"
    local startdate=$(date --date="@${startsec}")
    local stopdate=$(date --date="@${stopsec}")
    local min=$[ (${stopsec} - ${startsec}) / 60 ]
    local sec=$[ (${stopsec} - ${startsec}) % 60 ]

    echo
    echo "--- Backup Results ---"
    printf "%-5s %s\n" "Start" ": ${startdate}"
    printf "%-5s %s\n" "End"   ": ${stopdate}"
    printf "%-5s %s\n" "Total" ": ${min} minutes, ${sec} seconds" 
}

##
# Print backup error.
##
backup_print_error()
{
    local type="${1}"
    local path="${2}"
    local message="Unable to create backup: "
    case "${type}" in
        directory) message+="Directory " ;;
        file) message+="File " ;;
        *) return 1 ;;
    esac
    message+="'${path}' does not exist, or there is a permissions issue."
    return 0
}

##
# Check if input is a source directory.
# 
# The directory must exist and the user must have read and execute permissions.
##
backup_is_source()
{
    local src="${1}"
    if [ -d "${src}" -a -r "${src}" -a -x "${src}" ]
    then
        return 0
    else
        return 1
    fi
}

##
# Check if input is a destination directory.
# 
# The directory must exist and the user must have read, write, and execute
# permissions.
##
backup_is_destination()
{
    local dst="${1}"
    if [ -d "${dst}" -a -r "${dst}" -a -w "${dst}" -a -x "${dst}" ]
    then
        return 0
    else
        return 1
    fi
}

##
# Check ig input is a file.
# 
# The file must exist and the user must have read permissions.
##
backup_is_file()
{
    local IFS=$'|'
    for file in ${@}
    do
        if [ ! -f "${file}" -o ! -r "${file}" ]
        then
            return 1
        fi
    done
    return 0
}

##
# Run script.
##
main "${@}"
