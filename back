#!/bin/bash
# ------------------------------------------------------------------------------
# 
# File: back
# Author: Gabriel Gonzalez
# 
# Brief: A file/directory/system backup program.
# 
# ------------------------------------------------------------------------------

##
# Source utilities.
##
. "commandline.sh"
. "io.sh"

##
# Exit statuses.
##
EXIT_BACK_INVALID_DIRECTORY=10
EXIT_BACK_INVALID_FILE=11
EXIT_BACK_USER_NOT_ROOT=12

STATUS_NORMAL=0
STATUS_GETOPT=1
STATUS_ARGS=2
STATUS_SRCDIR=10
STATUS_DSTDIR=11
STATUS_ROOT=100

##
# Backup.
##
main()
{
    cli_options "-h|--help             |Print program usage." \
                "-b|--backup=src:::    |Backup one or more directories. Must be run with '-d' and, optionally, with '-e'." \
                "-d|--destination=dest:|Destination path to save backup to." \
                "-e|--exclude=dir:::   |Directories to exclude from the backup." \
                "-f|--files=files:::   |Backup one or more files. Appends '.bak' to the name." \
                "-F|--full-backup      |Full backup of entire system. Must be run with '-d' and, optionally, with '-e'." \
                "-o|--options=:        |Additional rsync options." \
                "-v|--verbose          |Print verbose output."
    cli_parse "${@}"

    local help=$(cli_get "help")
    local backup=$(cli_get "backup")
    local destination=$(cli_get "destination")
    local exclude=$(cli_get "exclude")
    local files=$(cli_get "files")
    local fullbackup=$(cli_get "full-backup")
    local options=$(cli_get "options")

    if [ -z "${exclude}" ]
    then
        exclude="none"
    fi
    if [ -z "${options}" ]
    then
        options="none"
    fi

    if [ -n "${help}" ]
    then
        cli_usage
    elif [ -n "${backup}" ]
    then
        back_directory_backup "${backup}" "${destination}" "${exclude}" \
                              "${options}"
    elif [ -n "${files}" ]
    then
        back_file_backup "${files}"
    elif [ -n "${fullbackup}" ]
    then
        back_full_backup "${destination}" "${exclude}" "${options}"
    else
        :
    fi
    exit $?
}

##
# Backup one or more directories.
##
back_directory_backup()
{
    local src="${1}"
    local dst="${2}"
    local exclude="${3}"
    local options="${4}"
    local IFS=$'|'
    if  ! back_is_destination "${dst}"
    then
        back_print_error "directory" "${dst}"
        return ${EXIT_BACK_INVALID_DIRECTORY}
    fi
    for d in ${src}
    do
        if ! back_is_source "${src}"
        then
            back_print_error "directory" "${d}"
            return ${EXIT_BACK_INVALID_DIRECTORY}
        fi
    done
    rsync_backup "${src}" "${dst}" "${exclude}" "${options}"
    return $?
}

##
# Backup one or more files.
# 
# Append ".bak" to file backups.
##
back_file_backup()
{
    local file="${1}"
    local IFS=$'|'
    for f in ${file}
    do
        if ! back_is_file "${f}"
        then
            back_print_error "file" "${f}"
            return ${EXIT_BACK_INVALID_FILE}
        fi
        cp -anv "${f}" "${f}.bak"
    done
}

##
# Create a full system backup.
##
back_full_backup()
{
    local dst="${1}"
    local exclude="${2}"
    local options="${3}"
    if [ ${UID} -ne 0 ]
    then
        print_err "Unable to run full backup: Must be run as root."
        exit ${EXIT_BACK_USER_NOT_ROOT}
    fi
    if  ! back_is_destination "${dst}"
    then
        back_print_error "directory" "${dst}"
        return ${EXIT_BACK_INVALID_DIRECTORY}
    fi

    print_info "Running Full System Backup."

    exclude+="|/home/*/.thumbnails|/home/*/.cache|/home/*/.mozilla/firefox/*.default/storage"
    local src=

    options+="|--link-dest=${dst}"

    local date=$(date +%F)
    local latestlink="${dst}/latest"
    local latestdir="${dst}${date}"
    local log="${latestdir}/Backup_Summary_$(date +%T%z).log"
    mkdir -pv "${latestdir}"

    back_directory_backup "${src}" "${dst}" "${exclude}" "${options}" \
        | tee -a "${log}"
    sed -i 's/\r/\n/g' "${log}" 

    rm -f "${latestlink}"
    ln -sv "${latestdir}" "${latestlink}"
}

##
# Use rsync to backup.
##
rsync_backup()
{
    local src="${1}"
    local dst="${2}"
    local exclude="${3}"
    local options="${4}"
    local srcdirs=

    # Check existence of source and destination locations
    srcdirs=($(get_source_directories "${src}"))
    if [ $? -ne 0 ]; then
        exit ${STATUS_SRCDIR}
    fi

    local IFS=$'|'
    rsync -aEHAXxPhv ${src} "${dst}"
}

# ******************************************************************************
# Print backup done message
print_backup_done()
{
    local startsec="${1}"
    local stopsec="${2}"
    local startdate=$(date --date="@${startsec}")
    local stopdate=$(date --date="@${stopsec}")
    local min=$[ (${stopsec} - ${startsec}) / 60 ]
    local sec=$[ (${stopsec} - ${startsec}) % 60 ]

    echo
    echo "--- Backup Results ---"
    printf "%-5s %s\n" "Start" ": ${startdate}"
    printf "%-5s %s\n" "End"   ": ${stopdate}"
    printf "%-5s %s\n" "Total" ": ${min} minutes, ${sec} seconds" 
}

##
# Print backup error.
##
back_print_error()
{
    local type="${1}"
    local path="${2}"
    local message="Unable to create backup: "
    case "${type}" in
        directory) message+="Directory " ;;
        file) message+="File " ;;
        *) return 1 ;;
    esac
    message+="'${path}' does not exist, or there is a permissions issue."
    return 0
}

##
# Check if input is a source directory.
# 
# The directory must exist and the user must have read and execute permissions.
##
back_is_source()
{
    local src="${1}"
    if [ -d "${src}" -a -r "${src}" -a -x "${src}" ]
    then
        return 0
    else
        return 1
    fi
}

##
# Check if input is a destination directory.
# 
# The directory must exist and the user must have read, write, and execute
# permissions.
##
back_is_destination()
{
    local dst="${1}"
    if [ -d "${dst}" -a -r "${dst}" -a -w "${dst}" -a -x "${dst}" ]
    then
        return 0
    else
        return 1
    fi
}

##
# Check ig input is a file.
# 
# The file must exist and the user must have read permissions.
##
back_is_file()
{
    local IFS=$'|'
    for file in ${@}
    do
        if [ ! -f "${file}" -o ! -r "${file}" ]
        then
            return 1
        fi
    done
    return 0
}

##
# Run script.
##
main "${@}"
